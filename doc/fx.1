.\"t
.\" Automatically generated by Pandoc 2.2.3.2
.\"
.TH "fx" "1" "" "Version 20.0.2" "Command\-line JSON processing tool"
.hy
.SH NAME
.PP
\f[B]fx\f[] \[em] Command\-line JSON processing tool
.SH SYNOPSIS
.PP
\f[B]fx\f[] \f[B][options]\f[] \f[I]inputfile.json\f[]
.SH DESCRIPTION
.PP
fx can work in two modes: cli and interactive.
To start interactive mode pipe any JSON into fx:
.PP
$ curl \&... | fx
.PP
Or pass a filename as the first parameter:
.PP
$ fx my.json
.PP
If any argument was passed, fx will apply it and prints to stdout.
.SS Anonymous function
.PP
Use an anonymous function as reducer which gets JSON and processes it:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ [{"bar":\ "value"}]}\[aq]\ |\ fx\ \[aq]x\ =>\ x.foo[0].bar\[aq]
value
\f[]
.fi
.SS Binding
.PP
If you don't pass anonymous function \f[C]param\ =>\ ...\f[], code will
be automatically transformed into anonymous function.
And you can get access to JSON by \f[C]this\f[] keyword:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ [{"bar":\ "value"}]}\[aq]\ |\ fx\ \[aq]this.foo[0].bar\[aq]
value
\f[]
.fi
.SS Dot
.PP
It is possible to omit \f[C]this\f[] keyword:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ [{"bar":\ "value"}]}\[aq]\ |\ fx\ .foo[0].bar
value
\f[]
.fi
.PP
If a single dot is passed, the input JSON will be formatted but
otherwise unaltered:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ "bar"}\[aq]\ |\ fx\ .
{
\ \ "foo":\ "bar"
}
\f[]
.fi
.SS Map
.PP
One of the frequent operations is mapping some function on an array.
For example, to extract some values.
.IP
.nf
\f[C]
[
\ \ {
\ \ \ \ "author":\ {
\ \ \ \ \ \ "name":\ "antonmedv"
\ \ \ \ }
\ \ },
\ \ {...},
\ \ ...
]
\f[]
.fi
.PP
And we want to collect names of each object in the array.
We can do this by mapping anonymous function:
.IP
.nf
\f[C]
$\ cat\ ...\ |\ fx\ \[aq].map(x\ =>\ x.author.name)\[aq]
\f[]
.fi
.PP
Or we can do the same by using jq\-like syntax:
.IP
.nf
\f[C]
$\ cat\ ...\ |\ fx\ .[].author.name
[
\ \ "antonmedv",
\ \ ...
]
\f[]
.fi
.RS
.PP
Note what \f[C][]\f[] can be applied to map object values.
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ 1,\ "bar":\ 2}\[aq]\ |\ fx\ .[]
[1,\ 2]
\f[]
.fi
.RE
.SS Chaining
.PP
You can pass any number of anonymous functions for reducing JSON:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"foo":\ [{"bar":\ "value"}]}\[aq]\ |\ fx\ \[aq]x\ =>\ x.foo\[aq]\ \[aq]this[0]\[aq]\ \[aq]this.bar\[aq]
value
\f[]
.fi
.SS Updating
.PP
You can update existing JSON using the spread operator:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"count":\ 0}\[aq]\ |\ fx\ \[aq]{...this,\ count:\ 1}\[aq]
{
\ \ "count":\ 1
}
\f[]
.fi
.SS Edit\-in\-place
.PP
\f[C]fx\f[] provides a function \f[C]save\f[] which will save everything
in place and return saved object.
This function can be only used with filename as first argument to
\f[C]fx\f[] command.
.PP
Usage:
.IP
.nf
\f[C]
fx\ data.json\ \[aq]{...this,\ count:\ this.count+1}\[aq]\ save\ .count
\f[]
.fi
.SS Query language
.PP
If you want to use query language, for example
jsonata (http://jsonata.org/) you can use helper function like this:
.IP
.nf
\f[C]
global.jsonata\ =\ expr\ =>\ require(\[aq]jsonata\[aq])(expr).evaluate
\f[]
.fi
.PP
And use it like this:
.IP
.nf
\f[C]
curl\ ...\ |\ fx\ \[aq]jsonata("$sum(Order.Product.(Price\ *\ Quantity))")\[aq]
\f[]
.fi
.PP
Instead you can create next alias in \f[I].bashrc\f[] file:
.IP
.nf
\f[C]
alias\ jsonata=\[aq]FX_APPLY=jsonata\ fx\[aq]
\f[]
.fi
.PP
And now all code arguments to \f[C]jsonata\f[] will be passed through
\f[C]jsonata\f[] helper.
And now you can use it like this:
.IP
.nf
\f[C]
curl\ ...\ |\ jsonata\ \[aq]$sum(Order.Product.(Price\ *\ Quantity))\[aq]
\f[]
.fi
.SS Formatting
.PP
If you need output other than JSON (for example arguments for xargs), do
not return anything from the reducer.
\f[C]undefined\f[] value is printed into stderr by default.
.IP
.nf
\f[C]
echo\ \[aq][]\[aq]\ |\ fx\ \[aq]void\ 0\[aq]
undefined
\f[]
.fi
.IP
.nf
\f[C]
echo\ \[aq][1,2,3]\[aq]\ |\ fx\ \[aq]this.forEach(x\ =>\ console.log(+x))\[aq]\ 2>/dev/null\ |\ xargs\ echo
1\ 2\ 3
\f[]
.fi
.SS Other examples
.PP
Convert object to array:
.IP
.nf
\f[C]
$\ cat\ package.json\ |\ fx\ \[aq]Object.keys(this.dependencies)\[aq]
\f[]
.fi
.PP
Or by two functions:
.IP
.nf
\f[C]
$\ cat\ package.json\ |\ fx\ .dependencies\ Object.keys
\f[]
.fi
.PP
By the way, fx has shortcut for \f[C]Object.keys\f[].
Previous example can be rewritten as:
.IP
.nf
\f[C]
$\ cat\ package.json\ |\ fx\ .dependencies\ ?
\f[]
.fi
.SS Streaming mode
.PP
\f[C]fx\f[] supports line\-delimited JSON and concatenated JSON
streaming.
.IP
.nf
\f[C]
$\ kubectl\ logs\ ...\ |\ fx\ .message
\f[]
.fi
.RS
.PP
Note what is object lacks \f[C]message\f[] field, \f[I]undefined\f[]
will be printed to stderr.
This is useful to see if you are skipping some objects.
But if you want to hide them, redirect stderr to \f[C]/dev/null\f[].
.RE
.SS Filtering
.PP
Sometimes it is necessary to omit some messages in JSON stream, or
select only specified log messages.
For this purpose, \f[C]fx\f[] has special helpers
\f[C]select\f[]/\f[C]filter\f[], pass function into it to select/filter
JSON messages.
.IP
.nf
\f[C]
$\ kubectl\ logs\ ...\ |\ fx\ \[aq]select(x\ =>\ x.status\ ==\ 500)\[aq]\ .message
\f[]
.fi
.IP
.nf
\f[C]
$\ kubectl\ logs\ ...\ |\ fx\ \[aq]filter(x\ =>\ x.status\ <\ 499)\[aq]\ .message
\f[]
.fi
.RS
.PP
If \f[C]filter\f[]/\f[C]select\f[] overridden in \f[I].fxrc\f[] you
still able to access them with prefix: \f[C]std.select(cb)\f[] or
\f[C]std.filter(cd)\f[]
.RE
.SS Interactive mode
.PP
Click on fields to expand or collapse JSON tree, use mouse wheel to
scroll view.
.PP
Next commands available in interactive mode:
.PP
.TS
tab(@);
l l.
T{
Key
T}@T{
Command
T}
_
T{
\f[C]q\f[] or \f[C]Esc\f[] or \f[C]Ctrl\f[]+\f[C]c\f[]
T}@T{
Exit
T}
T{
\f[C]up\f[] or \f[C]k\f[]
T}@T{
Move cursor up
T}
T{
\f[C]down\f[] or \f[C]j\f[]
T}@T{
Move cursor down
T}
T{
\f[C]left\f[] or \f[C]h\f[]
T}@T{
Collapse
T}
T{
\f[C]right\f[] or \f[C]l\f[]
T}@T{
Expand
T}
T{
\f[C]Shift\f[]+\f[C]right\f[] or \f[C]L\f[]
T}@T{
Expand all under cursor
T}
T{
\f[C]Shift\f[]+\f[C]left\f[] or \f[C]K\f[]
T}@T{
Collapse all under cursor
T}
T{
\f[C]e\f[]
T}@T{
Expand all
T}
T{
\f[C]E\f[]
T}@T{
Collapse all
T}
T{
\f[C]g\f[]
T}@T{
Scroll to top
T}
T{
\f[C]G\f[]
T}@T{
Scroll to bottom
T}
T{
\f[C]\&.\f[]
T}@T{
Edit filter
T}
T{
\f[C]/\f[]
T}@T{
Search
T}
T{
\f[C]n\f[]
T}@T{
Find next
T}
T{
\f[C]p\f[]
T}@T{
Exit and print JSON to stdout
T}
T{
\f[C]P\f[]
T}@T{
Exit and print fully expanded JSON to stdout
T}
.TE
.PP
These commands are available when editing the filter:
.PP
.TS
tab(@);
l l.
T{
Key
T}@T{
Command
T}
_
T{
\f[C]Enter\f[]
T}@T{
Apply filter
T}
T{
\f[C]Ctrl\f[]+\f[C]u\f[]
T}@T{
Clear filter
T}
T{
\f[C]Ctrl\f[]+\f[C]w\f[]
T}@T{
Delete last part
T}
T{
\f[C]up\f[]/\f[C]down\f[]
T}@T{
Select autocomplete
T}
.TE
.SS Searching
.PP
Press \f[C]/\f[] and type regexp pattern to search in current JSON.
Search work with currently applied filter.
.PP
Examples of pattern and corresponding regexp:
.PP
.TS
tab(@);
l l.
T{
Pattern
T}@T{
RegExp
T}
_
T{
\f[C]/apple\f[]
T}@T{
\f[C]/apple/ig\f[]
T}
T{
\f[C]/apple/\f[]
T}@T{
\f[C]/apple/\f[]
T}
T{
\f[C]/apple/u\f[]
T}@T{
\f[C]/apple/u\f[]
T}
T{
\f[C]/\\w+\f[]
T}@T{
\f[C]/\\w+/ig\f[]
T}
.TE
.SS Selecting text
.PP
You may found what you can't just select text in fx.
This is due the fact that all mouse events redirected to stdin.
To be able select again you need instruct your terminal not to do it.
This can be done by holding special keys while selecting:
.PP
.TS
tab(@);
l l.
T{
Key
T}@T{
Terminal
T}
_
T{
\f[C]Option\f[]+\f[C]Mouse\f[]
T}@T{
iTerm2, Hyper
T}
T{
\f[C]Fn\f[]+\f[C]Mouse\f[]
T}@T{
Terminal.app
T}
T{
\f[C]Shift\f[]+\f[C]Mouse\f[]
T}@T{
Linux
T}
.TE
.RS
.PP
Note what you can press \f[C]p\f[]/\f[C]P\f[] to print everything to
stdout and select if there.
.RE
.SS Options
.TP
.B \[en]version
Show program version
.RS
.RE
.TP
.B \[en]help
Display help information
.RS
.RE
.SH FILES
.SS Using packages
.PP
Use any npm package by installing it globally:
.IP
.nf
\f[C]
$\ npm\ install\ \-g\ lodash
$\ cat\ package.json\ |\ fx\ \[aq]require("lodash").keys(this.dependencies)\[aq]
\f[]
.fi
.SS Using .fxrc
.PP
Create \f[I].fxrc\f[] file in \f[C]$HOME\f[] directory, and require any
packages or define global functions.
.PP
For example, access all lodash methods without \f[C]_\f[] prefix.
Put in your \f[C]\&.fxrc\f[] file:
.IP
.nf
\f[C]
Object.assign(global,\ require(\[aq]lodash/fp\[aq]))
\f[]
.fi
.PP
And now you will be able to call all lodash methods.
For example, see who's been committing to react recently:
.IP
.nf
\f[C]
curl\ \[aq]https://api.github.com/repos/facebook/react/commits?per_page=100\[aq]\ \\
|\ fx\ \[aq]groupBy("commit.author.name")\[aq]\ \[aq]mapValues(size)\[aq]\ toPairs\ \[aq]sortBy(1)\[aq]\ reverse\ \[aq]take(10)\[aq]\ fromPairs
\f[]
.fi
.RS
.PP
To be able require global modules make sure you have correct
\f[C]NODE_PATH\f[] env variable.
.IP
.nf
\f[C]
export\ NODE_PATH=`npm\ root\ \-g`
\f[]
.fi
.RE
.SH ENVIRONMENT
.PP
You may find that sometimes, on really big JSON files, fx prints an
error message like this:
.IP
.nf
\f[C]
FATAL\ ERROR:\ JavaScript\ heap\ out\ of\ memory\ 
\f[]
.fi
.PP
V8 limits memory usage to around 2 GB by default.
You can increase the limit by putting this line in your
\f[I].profile\f[]:
.IP
.nf
\f[C]
export\ NODE_OPTIONS=\[aq]\-\-max\-old\-space\-size=8192\[aq]
\f[]
.fi
.SH BUGS
.PP
See GitHub Issues: <https://github.com/antonmedv/fx/issues>
.SH AUTHOR
.PP
Anton Medvedev (anton+github\@medv.io)
.PP
<https://github.com/antonmedv/fx>
